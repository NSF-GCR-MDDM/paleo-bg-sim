#include "MiniBooNEBeamlineTrackingAction.hh"
#include "MiniBooNEBeamlineRunAction.hh"
#include "MiniBooNEBeamlineAnalysis.hh"
#include "G4Track.hh"
#include "G4RunManager.hh"
#include "G4TrackStatus.hh"
#include "G4SystemOfUnits.hh"
#include <cmath>

MiniBooNEBeamlineTrackingAction::MiniBooNEBeamlineTrackingAction(MiniBooNEBeamlineRunAction* runAction)
: G4UserTrackingAction(),
  fRunAction(runAction)
{} 

MiniBooNEBeamlineTrackingAction::~MiniBooNEBeamlineTrackingAction()
{}

void MiniBooNEBeamlineTrackingAction::PreUserTrackingAction(const G4Track* aTrack) {
    // Look for protons/neutrons/pions/kaons generated by primary protons in target. 
	// Fill relevant histograms.
    G4int parentID = aTrack->GetParentID();
    G4int PDGCode2 = aTrack->GetDynamicParticle()->GetPDGcode();
                                               
    if (PDGCode2 == 13 && aTrack->GetParentID() == 0) { // Looking for parent muons
		trackMap[aTrack->GetTrackID()] = aTrack; // store in map for neutron parent lookup
		G4ThreeVector momentum2 = aTrack->GetMomentum();
		G4ThreeVector position2 = aTrack->GetPosition();
		G4double kinE2 = aTrack->GetKineticEnergy();
		
		G4AnalysisManager* analysisManager = G4AnalysisManager::Instance();
		analysisManager->FillNtupleIColumn(1, 0, PDGCode2);
		analysisManager->FillNtupleDColumn(1, 1, kinE2);
		analysisManager->FillNtupleDColumn(1, 2, momentum2.x());
		analysisManager->FillNtupleDColumn(1, 3, momentum2.y());
		analysisManager->FillNtupleDColumn(1, 4, momentum2.z());
		analysisManager->FillNtupleDColumn(1, 5, position2.x());
		analysisManager->FillNtupleDColumn(1, 6, position2.y());
		analysisManager->FillNtupleDColumn(1, 7, position2.z());
		analysisManager->AddNtupleRow(1);
		analysisManager->FillH1(5, kinE2);
    } 
    
	// Get kinematics
    G4ThreeVector momentum = aTrack->GetMomentum();
    G4double transMom = sqrt(momentum.x()*momentum.x() + momentum.y()*momentum.y());
    G4double kinEnergy = aTrack->GetKineticEnergy();
    
    // ID the particle
    G4int PDGCode = aTrack->GetDynamicParticle()->GetPDGcode();
    
	G4AnalysisManager* analysisManager = G4AnalysisManager::Instance();
    if (PDGCode == 2212) { // protons
        analysisManager->FillH1(0, momentum.mag());
		analysisManager->FillH1(1, momentum.theta() * 1000.0); 
    }
    else if (PDGCode == 2112) { // neutrons
        analysisManager->FillH1(2, momentum.mag());

		// Find the parent muon by using the parent ID stored earlier
        if (parentID != 0) {
            std::map<G4int, const G4Track *>::iterator parentTrack = trackMap.find(parentID);
            if (parentTrack != trackMap.end()) {
                // Calculate the angle between the neutron and its parent (muon) momenta
                G4ThreeVector parentMomentum = parentTrack->second->GetMomentum();
                G4double cosTheta = (momentum.dot(parentMomentum)
									 / (momentum.mag() * parentMomentum.mag()));
                analysisManager->FillH1(3, cosTheta); // Fill cos(theta) histogram
            }	
        }
		
		analysisManager->FillH1(4, kinEnergy);
	}
}

void MiniBooNEBeamlineTrackingAction::PostUserTrackingAction(const G4Track* aTrack)
{
    // Check PDGCode (Particle Data Group Code)
    G4int PDGCode = aTrack->GetDynamicParticle()->GetPDGcode();
    G4AnalysisManager* analysisManager = G4AnalysisManager::Instance(); // Access analysis manager

    // Handle custom PDG code for decay tracking (e.g., PDGCode = -987654321 for certain particle types)
    if (PDGCode == -987654321) {
        // Get process name from the current step in track
        G4String procName = aTrack->GetStep()->GetPostStepPoint()->GetProcessDefinedStep()->GetProcessName();

        // Check if track is stopped and killed by decay process
        if (aTrack->GetTrackStatus() == fStopAndKill && procName == "Decay") {
            // Extract kinematic information about the particle
            G4double kinE = aTrack->GetKineticEnergy();
            G4ThreeVector momentum = aTrack->GetMomentum();
            G4ThreeVector position = aTrack->GetPosition();

            // For example, if dealing with kaons, store additional information
            if (PDGCode == 321 || PDGCode == -321) {
                // Volume and position info for kaon decay
                G4String volumeName = aTrack->GetVolume()->GetName();
                G4ThreeVector positionVtx = aTrack->GetVertexPosition();
                G4String volumeNameVtx = aTrack->GetLogicalVolumeAtVertex()->GetName();
                
                // You can now process this data or store it in histograms or ntuples
            }
        }
    }
}